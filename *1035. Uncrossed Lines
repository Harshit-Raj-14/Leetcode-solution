/* RECURSION + MEMORIZATION => ACCEPTED */
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int dp[][] = new int[nums1.length+1][nums2.length+1];
        for (int i = 0; i <= nums1.length; i++) {            //can also do this : for (int[] row : dp) {Arrays.fill(row, -1);}
            for (int j = 0; j <= nums2.length; j++) {
                dp[i][j] = -1;  // Initialize dp array with -1
            }
        }
        return solve(0, 0, nums1, nums2, dp);       //i and j initialised as 0
    }

    public int solve(int i, int j, int[]nums1, int[]nums2, int dp[][]){
        if(i==nums1.length || j==nums2.length) return 0;    //if any of the one reaches the end we have reached the solution
        if(dp[i][j]!=-1) return dp[i][j];
        int count=0;
        if(nums1[i]==nums2[j]){ 
            count= 1 + solve(i+1, j+1, nums1, nums2, dp);   //we got a match so take both i and j and move to next one
        }
        else{
            count+=Math.max(solve(i+1,j,nums1,nums2,dp), solve(i,j+1,nums1,nums2,dp));
        }
        return dp[i][j]=count;
    }
}


/* RECURSIVE SOLUTION - TIME LIMIT EXCEEDED */
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        return solve(0, 0, nums1, nums2);       //i and j initialised as 0
    }

    public int solve(int i, int j, int[]nums1, int[]nums2){
        if(i==nums1.length || j==nums2.length) return 0;
        int count=0;
        if(nums1[i]==nums2[j]){ 
            count= 1 + solve(i+1, j+1, nums1, nums2);   //we got a match so take both i and j and move to next one
        }
        else{
            count+=Math.max(solve(i+1,j,nums1,nums2), solve(i,j+1,nums1,nums2));
        }
        return count;
    }
}

LOGIC --- RECURSION
Case I : nums1[i]==nums2[j] then, counter++
Case II : else ---- two subcases -> leave one of them -> (leave i or leave j)
To, overcome TLE we will use MEMORIZATION


⭐⭐⭐ IMPORTANT ⭐⭐⭐
NOTE --- ❌Greedy -  ✅Recursion (DP)===> to get all cases and choose the maximum one

/* A FAILED APPROACH */  ====> VERDICT THE PROBLEM CANNOT BE SOLVED BY GREEDY BUT DP ===> SAME SITUATION IN LONGEST COMMON SUBSEQUENCE THERE ALSO DO DP AND NOT GREEDY
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int count=0;
        int ans=0;
        int flag=0;
        for(int i=0;i<nums1.length;i++){
            flag=0;
            for(int j=count; (j<nums2.length && flag==0); j++){
                if(nums1[i]==nums2[j]){
                    count=j+1;
                    ans++;
                    flag=1;
                }
            }
        }
        return ans;
    }
}

THE REASON IT FAISL BECAUSE THIS PROGRAM DOES NOT RETURN THE MAXIMUM BUT ONLY THE FIRST KIND, SIMILAR TO GREEDY.
Input
nums1 =
[1,1,2,1,2]
nums2 =
[1,3,2,3,1]
Use Testcase
Output
2   ==> YOU ONLY GET THIS BY CONSIDERING THE FIRST GREEDY CASE

Expected
3   ===> THIS IS THE MAXIMUM POSSIBLE


So, greedy won't work
