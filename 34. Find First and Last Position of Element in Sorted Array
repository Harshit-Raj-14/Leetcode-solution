/* O(logn) BINARY SEARCH */


LOGIC---
At first use binary search to find target.
When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid.

Hence there are two binary check functions sarcastically :
one to find target
and one to find where it stops being target

TYPE : NNNNN....YYYYYY...NNNNN

/* O(n) PARTIAL BINARY SEARCH */
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first=-1;
        int last=-1;
        int l=0;
        int r=nums.length-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            if(nums[mid]==target){
                int i=mid;
                while(i>=0 && nums[i]==target){ //making sure our first is the leftmost target
                    first=i;
                    i--;
                }
                i=mid;
                while(i<nums.length && nums[i]==target){//making sure our last is the rightmost target
                    last=i;
                    i++;
                }
            }
            if(nums[mid]>target){
                r=mid-1;
            }
            else l=mid+1;
        }
        return new int[] {first, last};
    }
}

LOGIC---
For testcase : [8,8,8,8,8,8,8] target =mid
The above will become binary search becomes a linear search becuase of your while step



/* O(n) LINEAR SEARCH */
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first=-1;
        int last=-1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                first=i;
                while(i<nums.length && nums[i]==target){
                    last=i;
                    i++;
                }
            }
        }
        return new int[] {first, last};
    }
}
